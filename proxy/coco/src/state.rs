//! Utility to work with the peer api of librad.

use std::{convert::TryFrom as _, iter::FromIterator, net::SocketAddr, path::PathBuf};

use either::Either;

use librad::{
    git::{
        identities,
        identities::{
            local::{self, LocalIdentity},
            person, project,
        },
        include::{self, Include},
        local::{transport, url::LocalUrl},
        refs::Refs,
        replication, tracking,
        types::{Namespace, Reference, Single},
    },
    git_ext::{OneLevel, RefLike},
    identities::{
        delegation::{Direct, Indirect},
        payload, Person, Project, SomeIdentity, Urn,
    },
    internal::canonical::Cstring,
    keys,
    net::peer::PeerApi,
    paths,
    peer::PeerId,
    signer::BoxedSigner,
};
use radicle_keystore::sign::Signer as _;
use radicle_surf::vcs::{git, git::git2};

use crate::{peer::gossip, project::peer, seed::Seed, source};

pub mod error;
pub use error::Error;

/// High-level interface to the coco monorepo and gossip layer.
#[derive(Clone)]
pub struct State {
    /// Internal handle on [`PeerApi`].
    pub(crate) api: PeerApi,
    /// Signer to sign artifacts generated by the user.
    signer: BoxedSigner,
}

impl State {
    /// Create a new [`State`] given a [`PeerApi`].
    #[must_use]
    pub const fn new(api: PeerApi, signer: BoxedSigner) -> Self {
        Self { api, signer }
    }

    /// Returns the [`PathBuf`] to the underlying monorepo.
    #[must_use]
    pub fn monorepo(&self) -> PathBuf {
        self.api.paths().git_dir().join("")
    }

    /// Returns the underlying [`paths::Paths`].
    #[must_use]
    pub fn paths(&self) -> paths::Paths {
        self.api.paths().clone()
    }

    #[must_use]
    pub fn settings(&self) -> transport::Settings {
        transport::Settings {
            paths: self.paths(),
            signer: self.signer.clone(),
        }
    }

    /// Check the storage to see if we have the given commit for project at `urn`.
    ///
    /// # Errors
    ///
    ///   * Checking the storage for the commit fails.
    pub async fn has_commit<Oid>(&self, urn: Urn, oid: Oid) -> Result<bool, Error>
    where
        Oid: AsRef<git2::Oid> + std::fmt::Debug + Send + 'static,
    {
        Ok(self
            .api
            .with_storage(move |storage| storage.has_commit(&urn, oid))
            .await??)
    }

    /// The local machine's [`PeerId`].WEB
    #[must_use]
    pub fn peer_id(&self) -> PeerId {
        self.api.peer_id()
    }

    /// The [`SocketAddr`] this [`PeerApi`] is listening on.
    pub fn listen_addrs(&self) -> impl Iterator<Item = SocketAddr> + '_ {
        self.api.listen_addrs()
    }

    /// Get the default owner for this `PeerApi`.
    pub async fn default_owner(&self) -> Result<Option<LocalIdentity>, Error> {
        self.api
            .with_storage(move |store| {
                if let Some(urn) = store.config()?.user()? {
                    return local::load(store, urn).map_err(Error::from);
                }

                Ok::<_, Error>(None)
            })
            .await?
    }

    /// Set the default owner for this `PeerApi`.
    ///
    /// # Errors
    ///
    ///   * Fails to set the default `rad/self` for this `PeerApi`.
    pub async fn set_default_owner<U>(&self, user: U) -> Result<(), Error>
    where
        U: Into<Option<LocalIdentity>> + Send + Sync + 'static,
    {
        self.api
            .with_storage(move |storage| storage.config()?.set_user(user).map_err(Error::from))
            .await?
    }

    /// Initialise a [`User`] and make them the default owner of this [`PeerApi`].
    ///
    /// # Errors
    ///
    ///   * Fails to initialise `User`.
    ///   * Fails to verify `User`.
    ///   * Fails to set the default `rad/self` for this `PeerApi`.
    #[allow(clippy::single_match_else)]
    pub async fn init_owner(&self, name: String) -> Result<LocalIdentity, Error> {
        match self
            .api
            .with_storage(move |store| local::default(store))
            .await??
        {
            Some(owner) => Ok(owner),
            None => {
                let pk = keys::PublicKey::from(self.signer.public_key());
                let person = self
                    .api
                    .with_storage(move |store| {
                        person::create(
                            store,
                            payload::Person {
                                name: Cstring::from(name),
                            },
                            Direct::from_iter(vec![pk].into_iter()),
                        )
                    })
                    .await??;

                let urn = person.urn();
                let owner = self
                    .api
                    .with_storage(move |store| local::load(store, urn))
                    .await??
                    .ok_or_else(|| Error::PersonNotFound(person.urn()))?;

                {
                    let owner = owner.clone();
                    self.api
                        .with_storage(move |store| {
                            let mut config = store.config()?;
                            config.set_user(owner)?;

                            Ok::<_, Error>(())
                        })
                        .await??;
                }

                Ok(owner)
            }
        }
    }

    /// Given some hints as to where you might find it, get the urn of the project found at `url`.
    ///
    /// # Errors
    ///   * Could not successfully acquire a lock to the API.
    ///   * Could not open librad storage.
    ///   * Failed to clone the project.
    ///   * Failed to set the rad/self of this project.
    pub async fn clone_project<Addrs>(
        &self,
        urn: Urn,
        remote_peer: PeerId,
        addr_hints: Addrs,
    ) -> Result<(), Error>
    where
        Addrs: IntoIterator<Item = SocketAddr> + Send + 'static,
    {
        // TODO(finto): Since the owner is returned as Some we could forego the unwrap
        let owner = self.default_owner().await?.ok_or(Error::MissingOwner)?;
        self.api
            .with_storage(move |store| {
                replication::replicate(store, Some(owner), urn.clone(), remote_peer, addr_hints)
            })
            .await?
            .map_err(Error::from)
    }

    /// Get the project found at `urn`.
    ///
    /// # Errors
    ///
    ///   * Resolving the project fails.
    pub async fn get_project(&self, urn: Urn) -> Result<Option<Project>, Error> {
        self.api
            .with_storage(move |store| identities::project::get(store, &urn))
            .await?
            .map_err(Error::from)
    }

    /// Returns the list of [`librad_project::Project`]s for the local peer.
    ///
    /// # Errors
    ///
    ///   * Retrieving the project entities from the store fails.
    pub async fn list_projects(&self) -> Result<Vec<Project>, Error> {
        // FIXME(xla): Instead of implicitely expecting a presence of a default owner, there either
        // should be an explicit argument, or it's made impossible to call this function without an
        // owner associated with the state.
        let owner = match self.default_owner().await? {
            None => return Err(Error::MissingOwner),
            Some(owner) => owner.into_inner().into_inner(),
        };

        self.api
            .with_storage(move |store| {
                let projects = identities::any::list(store)?
                    .filter_map(Result::ok)
                    .filter_map(|id| match id {
                        SomeIdentity::Project(project) => {
                            let rad_self =
                                Reference::rad_self(Namespace::from(project.urn()), None);
                            let urn = Urn::try_from(rad_self).ok()?;
                            let project_self = person::get(store, &urn).ok()??;
                            // Filter projects that have a rad/self pointing to current default
                            // owner
                            if project_self == owner {
                                Some(project)
                            } else {
                                None
                            }
                        }
                        _ => None,
                    })
                    .collect::<Vec<_>>();

                Ok::<_, Error>(projects)
            })
            .await?
    }

    /// Retrieves the [`librad::git::refs::Refs`] for the state owner.
    ///
    /// # Errors
    ///
    /// * if opening the storage fails
    pub async fn list_owner_project_refs(&self, urn: Urn) -> Result<Option<Refs>, Error> {
        self.api
            .with_storage(move |store| Refs::load(store, &urn, None))
            .await?
            .map_err(Error::from)
    }

    /// Retrieves the [`librad::git::refs::Refs`] for the given project urn.
    ///
    /// # Errors
    ///
    /// * if opening the storage fails
    pub async fn list_peer_project_refs(
        &self,
        urn: Urn,
        peer_id: PeerId,
    ) -> Result<Option<Refs>, Error> {
        self.api
            .with_storage(move |store| Refs::load(store, &urn, Some(peer_id)))
            .await?
            .map_err(Error::from)
    }

    /// Returns the list of [`user::User`]s known for your peer.
    ///
    /// # Errors
    ///
    ///   * Retrieval of the user entities from the store fails.
    pub async fn list_users(&self) -> Result<Vec<Person>, Error> {
        self.api
            .with_storage(move |store| {
                let projects = identities::any::list(store)?
                    .filter_map(Result::ok)
                    .filter_map(|id| match id {
                        SomeIdentity::Person(person) => Some(person),
                        _ => None,
                    })
                    .collect::<Vec<_>>();

                Ok::<_, Error>(projects)
            })
            .await?
    }

    /// Given some hints as to where you might find it, get the urn of the user found at `url`.
    ///
    /// # Errors
    ///
    ///   * Could not successfully acquire a lock to the API.
    ///   * Could not open librad storage.
    ///   * Failed to clone the user.
    pub async fn clone_user<Addrs>(
        &self,
        urn: Urn,
        remote_peer: PeerId,
        addr_hints: Addrs,
    ) -> Result<(), Error>
    where
        Addrs: IntoIterator<Item = SocketAddr> + Send + 'static,
    {
        self.api
            .with_storage(move |store| {
                replication::replicate(store, None, urn, remote_peer, addr_hints)
            })
            .await?
            .map_err(Error::from)
    }

    /// Get the user found at `urn`.
    ///
    /// # Errors
    ///
    ///   * Resolving the user fails.
    ///   * Could not successfully acquire a lock to the API.
    pub async fn get_user(&self, urn: Urn) -> Result<Option<LocalIdentity>, Error> {
        self.api
            .with_storage(move |store| match identities::person::get(store, &urn)? {
                None => Ok(None),
                Some(person) => local::load(store, person.urn()),
            })
            .await?
            .map_err(Error::from)
    }

    /// Fetch any updates at the given `RadUrl`, providing address hints if we have them.
    ///
    /// # Errors
    ///
    ///   * Could not successfully acquire a lock to the API.
    ///   * Could not open librad storage.
    ///   * Failed to fetch the updates.
    ///   * Failed to set the rad/self of this project.
    pub async fn fetch<Addrs>(
        &self,
        urn: Urn,
        remote_peer: PeerId,
        addr_hints: Addrs,
    ) -> Result<(), Error>
    where
        Addrs: IntoIterator<Item = SocketAddr> + Send + 'static,
    {
        Ok(self
            .api
            .with_storage(move |store| {
                replication::replicate(store, None, urn, remote_peer, addr_hints)
            })
            .await??)
    }

    /// Provide a a repo [`git::Browser`] where the `Browser` is initialised with the provided
    /// `reference`.
    ///
    /// See [`State::find_default_branch`] and [`State::get_branch`] for obtaining a
    /// [`NamespacedRef`].
    ///
    /// # Errors
    ///   * If the namespace of the reference could not be converted to a [`git::Namespace`].
    ///   * If we could not open the backing storage.
    ///   * If we could not initialise the `Browser`.
    ///   * If the callback provided returned an error.
    pub async fn with_browser<F, T>(
        &self,
        reference: Reference<Single>,
        callback: F,
    ) -> Result<T, Error>
    where
        F: FnOnce(&mut git::Browser) -> Result<T, source::Error> + Send,
    {
        // CONSTRUCT PROEJECTS NAMESPACE
        let namespace = git::namespace::Namespace::try_from(
            reference
                .namespace
                .ok_or(Error::MissingNamespace)?
                .to_string()
                .as_str(),
        )?;

        // HANDLE HEADS
        let branch = match reference.remote {
            None => git::Branch::local(reference.name.as_str()),
            Some(peer) => git::Branch::remote(
                &format!("heads/{}", reference.name.as_str()),
                &peer.to_string(),
            ),
        };

        // OPEN BROWSER
        let monorepo = self.monorepo();
        let repo = git::Repository::new(monorepo).map_err(source::Error::from)?;
        let mut browser = git::Browser::new_with_namespace(&repo, &namespace, branch)
            .map_err(source::Error::from)?;

        // CALL CALLBACK
        callback(&mut browser).map_err(Error::from)
    }

    /// This method helps us get a branch for a given [`Urn`] and optional [`PeerId`].
    ///
    /// If the `branch_name` is `None` then we get the project for the given [`Urn`] and use its
    /// `default_branch`.
    ///
    /// # Errors
    ///   * If the storage operations fail.
    ///   * If the requested reference was not found.
    pub async fn get_branch<P, B>(
        &self,
        urn: Urn,
        remote: P,
        branch_name: B,
    ) -> Result<Reference<Single>, Error>
    where
        P: Into<Option<PeerId>> + Clone + Send,
        B: Into<Option<Cstring>> + Clone + Send,
    {
        let name = match branch_name.into() {
            None => {
                let project = self
                    .get_project(urn.clone())
                    .await?
                    .ok_or_else(|| Error::ProjectNotFound(urn.clone()))?;
                project
                    .subject()
                    .default_branch
                    .clone()
                    .ok_or(Error::NoDefaultBranch {
                        name: "".to_string(),
                        urn: urn.clone(),
                    })?
            }
            Some(name) => name,
        }
        .parse()?;

        let remote = match remote.into() {
            Some(peer_id) if peer_id == self.peer_id() => None,
            Some(peer_id) => Some(peer_id),
            None => None,
        };
        let reference = Reference::head(Namespace::from(urn), remote, name);
        let exists = {
            let reference = reference.clone();
            self.api
                .with_storage(move |storage| storage.has_ref(&reference))
                .await??
        };

        if exists {
            Ok(reference)
        } else {
            Err(Error::MissingRef { reference })
        }
    }

    /// This method helps us get the default branch for a given [`Urn`].
    ///
    /// It does this by:
    ///     * First checking if the owner of this storage has a reference to the default
    /// branch.
    ///     * If the owner does not have this reference then it falls back to the first maintainer.
    ///
    /// # Errors
    ///   * If the storage operations fail.
    ///   * If no default branch was found for the provided [`Urn`].
    pub async fn find_default_branch(&self, urn: Urn) -> Result<Reference<Single>, Error> {
        let project = self
            .get_project(urn.clone())
            .await?
            .ok_or_else(|| Error::ProjectNotFound(urn.clone()))?;

        let default_branch =
            project
                .subject()
                .default_branch
                .clone()
                .ok_or(Error::NoDefaultBranch {
                    name: "".to_string(),
                    urn: urn.clone(),
                })?;

        // TODO(xla): Check for all delegations if there is default branch.
        let peer = project
            .delegations()
            .iter()
            .flat_map(|either| match either {
                Either::Left(pk) => Either::Left(std::iter::once(PeerId::from(*pk))),
                Either::Right(indirect) => {
                    Either::Right(indirect.delegations().iter().map(|pk| PeerId::from(*pk)))
                }
            })
            .next()
            .expect("missing delegation");

        let (owner, peer) = tokio::join!(
            self.get_branch(urn.clone(), None, default_branch.to_owned()),
            self.get_branch(urn.clone(), peer, default_branch.to_owned())
        );
        match owner.or(peer) {
            Ok(reference) => Ok(reference),
            Err(Error::MissingRef { .. }) => Err(Error::NoDefaultBranch {
                name: project.subject().name.to_string(),
                urn,
            }),
            Err(err) => Err(err),
        }
    }

    /// Initialize a [`librad_project::Project`] that is owned by the `owner`.
    /// This kicks off the history of the project, tracked by `librad`'s mono-repo.
    ///
    /// # Errors
    ///
    /// Will error if:
    ///     * The signing of the project metadata fails.
    ///     * The interaction with `librad` [`librad::git::storage::Storage`] fails.
    pub async fn init_project(
        &self,
        owner: &LocalIdentity,
        create: crate::project::Create,
    ) -> Result<Project, Error> {
        let default_branch = create.default_branch.to_string();
        let description = create.description.to_string();
        let name = create
            .repo
            .project_name()
            .map_err(crate::project::create::Error::from)?;
        let owner = owner.clone();
        let project = self
            .api
            .with_storage(move |store| {
                project::create(
                    store,
                    owner.clone(),
                    payload::Project {
                        default_branch: Some(Cstring::from(default_branch)),
                        description: Some(Cstring::from(description)),
                        name: Cstring::from(name),
                    },
                    Indirect::from(owner.into_inner().into_inner()),
                )
            })
            .await??;
        log::debug!(
            "Created project '{}#{}'",
            project.urn(),
            project.subject().name
        );

        // TODO(xla): Validate project working copy before creation and don't depend on URL.
        let url = LocalUrl::from(project.urn());
        let repository = create
            .validate(url)
            .map_err(crate::project::create::Error::from)?;

        let repo = repository
            .setup_repo(
                transport::Settings {
                    paths: self.api.paths().clone(),
                    signer: self.signer.clone(),
                },
                project
                    .subject()
                    .description
                    .as_deref()
                    .unwrap_or(&String::default()),
            )
            .map_err(crate::project::create::Error::from)?;
        let include_path = self.update_include(project.urn()).await?;
        include::set_include_path(&repo, include_path)?;
        crate::peer::gossip::announce(self, &project.urn(), None).await;

        Ok(project)
    }

    /// Create a [`user::User`] with the provided `handle`. This assumes that you are creating a
    /// user that uses the secret key the `PeerApi` was configured with.
    ///
    /// # Errors
    ///
    /// Will error if:
    ///     * The signing of the user metadata fails.
    ///     * The interaction with `librad` [`librad::git::storage::Storage`] fails.
    pub async fn init_user(&self, name: String) -> Result<LocalIdentity, Error> {
        let pk = keys::PublicKey::from(self.signer.public_key());
        self.api
            .with_storage(move |store| {
                let malkovich = person::create(
                    store,
                    payload::Person {
                        name: Cstring::from(name),
                    },
                    Direct::from_iter(vec![pk].into_iter()),
                )?;

                Ok::<_, Error>(local::load(store, malkovich.urn())?)
            })
            .await??
            .ok_or(Error::IdentityCreationFailed)
    }

    /// Wrapper around the storage track.
    ///
    /// # Errors
    ///
    /// * When the storage operation fails.
    pub async fn track(&self, urn: Urn, remote_peer: PeerId) -> Result<(), Error> {
        {
            let urn = urn.clone();
            self.api
                .with_storage(move |store| tracking::track(store, &urn, remote_peer))
                .await??;
        }

        gossip::query(self, urn.clone(), Some(remote_peer)).await;
        let path = self.update_include(urn).await?;
        log::debug!("Updated include path @ `{}`", path.display());
        Ok(())
    }

    /// Wrapper around the storage untrack.
    ///
    /// # Errors
    ///
    /// * When the storage operation fails.
    pub async fn untrack(&self, urn: Urn, remote_peer: PeerId) -> Result<bool, Error> {
        let res = {
            let urn = urn.clone();
            self.api
                .with_storage(move |store| tracking::untrack(store, &urn, remote_peer))
                .await??
        };

        // Only need to update if we did untrack an existing peer
        if res {
            let path = self.update_include(urn).await?;
            log::debug!("Updated include path @ `{}`", path.display());
        }
        Ok(res)
    }

    /// Get the [`user::User`]s that are tracking this project, including their [`PeerId`].
    ///
    /// # Errors
    ///
    /// * If we could not acquire the lock
    /// * If we could not open the storage
    /// * If did not have the `urn` in storage
    /// * If we could not fetch the tracked peers
    /// * If we could not get the `rad/self` of the peer
    pub async fn tracked(
        &self,
        urn: Urn,
    ) -> Result<Vec<crate::project::Peer<peer::Status<Person>>>, Error> {
        let project = self
            .get_project(urn.clone())
            .await?
            .ok_or_else(|| Error::ProjectNotFound(urn.clone()))?;

        self.api
            .with_storage(move |store| {
                let mut peers = vec![];

                for peer_id in tracking::tracked(store, &urn)? {
                    let ref_self = Reference::rad_self(Namespace::from(urn.clone()), peer_id);
                    let status = if store.has_ref(&ref_self)? {
                        let malkovich_urn = Urn::try_from(ref_self).unwrap();
                        let malkovich = person::get(store, &malkovich_urn)?
                            .ok_or(Error::PersonNotFound(malkovich_urn))?;

                        if project
                            .delegations()
                            .owner(peer_id.as_public_key())
                            .is_some()
                        {
                            peer::Status::replicated(peer::Role::Maintainer, malkovich)
                        } else if store.has_ref(&Reference::rad_signed_refs(
                            Namespace::from(urn.clone()),
                            peer_id,
                        ))? {
                            peer::Status::replicated(peer::Role::Contributor, malkovich)
                        } else {
                            peer::Status::replicated(peer::Role::Tracker, malkovich)
                        }
                    } else {
                        peer::Status::NotReplicated
                    };

                    peers.push(crate::project::Peer::Remote { peer_id, status });
                }

                Ok::<_, Error>(peers)
            })
            .await?
    }

    // TODO(xla): Account for projects not replicated but wanted.
    /// Constructs the list of [`project::Peer`] for the given `urn`. The basis is the list of
    /// tracking peers of the project combined with the local view.
    ///
    /// # Errors
    ///
    /// * if the project is not present in the monorepo
    /// * if the retrieval of tracking peers fails
    ///
    /// # Panics
    ///
    /// * if the default owner can't be fetched
    #[allow(clippy::blocks_in_if_conditions)]
    pub async fn list_project_peers(
        &self,
        urn: Urn,
    ) -> Result<Vec<crate::project::Peer<peer::Status<Person>>>, Error> {
        let project = self
            .get_project(urn.clone())
            .await?
            .ok_or_else(|| Error::ProjectNotFound(urn.clone()))?;

        let mut peers = vec![];

        let owner = self
            .default_owner()
            .await?
            .ok_or(Error::MissingOwner)?
            .into_inner()
            .into_inner();

        // CHECK IF OWNER IS MAINTAINER
        let status = if project
            .delegations()
            .owner(self.peer_id().as_public_key())
            .is_some()
        {
            peer::Status::replicated(peer::Role::Maintainer, owner)
        // CHECK IF OWNER IS CONTRIBUTOR
        } else if self
            .api
            .with_storage(move |store| {
                store.has_ref(&Reference::rad_signed_refs(
                    Namespace::from(project.urn()),
                    None,
                ))
            })
            .await??
        {
            peer::Status::replicated(peer::Role::Contributor, owner)
        // CHECK IF OWNER IS TRACKER
        } else {
            peer::Status::replicated(peer::Role::Tracker, owner)
        };

        peers.push(crate::project::Peer::Local {
            peer_id: self.peer_id(),
            status,
        });

        let mut remotes = self.tracked(urn).await?;

        peers.append(&mut remotes);

        Ok(peers)
    }

    /// Creates a working copy for the project of the given `urn`.
    ///
    /// The `destination` is the directory where the caller wishes to place the working copy.
    ///
    /// The `peer_id` is from which peer we wish to base our checkout from.
    ///
    /// # Errors
    ///
    /// * if the project can't be found
    /// * if the include file creation fails
    /// * if the clone of the working copy fails
    pub async fn checkout<P>(
        &self,
        urn: Urn,
        peer_id: P,
        destination: PathBuf,
    ) -> Result<PathBuf, Error>
    where
        P: Into<Option<PeerId>> + Send + 'static,
    {
        let peer_id = peer_id.into();
        let proj = self
            .get_project(urn.clone())
            .await?
            .ok_or_else(|| Error::ProjectNotFound(urn.clone()))?;
        let include_path = self.update_include(urn.clone()).await?;
        let default_branch: OneLevel = OneLevel::from(
            proj.subject()
                .default_branch
                .clone()
                .ok_or(Error::NoDefaultBranch {
                    name: "".to_string(),
                    urn: urn.clone(),
                })?
                .parse::<RefLike>()?,
        );
        let checkout = crate::project::Checkout {
            urn: proj.urn(),
            name: proj.subject().name.to_string(),
            default_branch,
            path: destination,
            include_path,
        };

        log::debug!("Determing Owner");
        let ownership = match peer_id {
            None => crate::project::checkout::Ownership::Local(self.peer_id()),
            Some(remote) => {
                let handle = {
                    let ref_self = Reference::rad_self(Namespace::from(urn.clone()), peer_id);
                    log::debug!("rad/self -> `{}`", ref_self);
                    log::debug!("Monorepo: {}", self.monorepo().display());
                    let person = self
                        .api
                        .with_storage(move |store| {
                            let malkovich_urn = Urn::try_from(ref_self).unwrap();
                            log::debug!("Urn -> {}", malkovich_urn);
                            let p = person::get(store, &malkovich_urn)?
                                .ok_or(Error::PersonNotFound(malkovich_urn))?;

                            Ok::<_, Error>(p)
                        })
                        .await??;

                    person.subject().name.to_string()
                };

                crate::project::checkout::Ownership::Remote {
                    handle,
                    remote,
                    local: self.peer_id(),
                }
            }
        };

        let settings = transport::Settings {
            paths: self.paths(),
            signer: self.signer.clone(),
        };
        log::debug!("Cloning");
        let path = tokio::task::spawn_blocking(move || {
            checkout.run(settings, ownership).map_err(Error::from)
        })
        .await
        .expect("blocking checkout failed")?;

        Ok(path)
    }

    /// Prepare the include file for the given `project` with the latest tracked peers.
    ///
    /// # Errors
    ///
    /// * if getting the list of tracked peers fails
    pub async fn update_include(&self, urn: Urn) -> Result<PathBuf, Error> {
        let local_url = LocalUrl::from(urn.clone());
        let tracked = self.tracked(urn).await?;
        let include = Include::from_tracked_persons(
            self.paths().git_includes_dir().to_path_buf(),
            local_url,
            tracked.into_iter().filter_map(|peer| {
                crate::project::Peer::replicated_remote(peer)
                    .map(|(p, u)| (RefLike::try_from(u.subject().name.to_string()).unwrap(), p))
            }),
        );
        let include_path = include.file_path();
        log::info!("creating include file @ '{:?}'", include_path);
        include.save()?;

        Ok(include_path)
    }
}

impl From<&State> for Seed {
    fn from(state: &State) -> Self {
        Self {
            peer_id: state.peer_id(),
            addrs: state.listen_addrs().collect(),
        }
    }
}

#[allow(clippy::panic, clippy::unwrap_used)]
#[cfg(test)]
mod test {
    use std::{env, path::PathBuf};

    use librad::{git_ext::OneLevel, keys::SecretKey, net, reflike};

    use crate::{config, control, project, signer};

    use super::State;

    fn fakie_project(path: PathBuf) -> project::Create {
        project::Create {
            repo: project::Repo::New {
                path,
                name: "fakie-nose-kickflip-backside-180-to-handplant".to_string(),
            },
            description: "rad git tricks".to_string(),
            default_branch: OneLevel::from(reflike!("dope")),
        }
    }

    fn radicle_project(path: PathBuf) -> project::Create {
        project::Create {
            repo: project::Repo::New {
                path,
                name: "radicalise".to_string(),
            },
            description: "the people".to_string(),
            default_branch: OneLevel::from(reflike!("power")),
        }
    }

    #[tokio::test]
    async fn can_create_user() -> Result<(), Box<dyn std::error::Error>> {
        let tmp_dir = tempfile::tempdir().expect("failed to create temdir");
        let key = SecretKey::new();
        let signer = signer::BoxedSigner::from(key.clone());
        let config = config::default(signer.clone(), tmp_dir.path())?;
        let disco = config::static_seed_discovery(&[]);
        let peer = net::peer::Peer::bootstrap(config, disco).await?;
        let (api, _run_loop) = peer.accept()?;
        let state = State::new(api, signer);

        let annie = state.init_user("annie_are_you_ok?".to_string()).await;
        assert!(annie.is_ok());

        Ok(())
    }

    #[tokio::test]
    async fn can_create_project() -> Result<(), Box<dyn std::error::Error>> {
        let tmp_dir = tempfile::tempdir().expect("failed to create temdir");
        env::set_var("RAD_HOME", tmp_dir.path());
        let repo_path = tmp_dir.path().join("radicle");
        let key = SecretKey::new();
        let signer = signer::BoxedSigner::from(key.clone());
        let config = config::default(signer.clone(), tmp_dir.path())?;
        let disco = config::static_seed_discovery(&[]);
        let peer = net::peer::Peer::bootstrap(config, disco).await?;
        let (api, _run_loop) = peer.accept()?;
        let state = State::new(api, signer);

        let user = state.init_owner("cloudhead".to_string()).await?;
        let project = state
            .init_project(&user, radicle_project(repo_path.clone()))
            .await;

        assert!(project.is_ok());
        assert!(repo_path.join("radicalise").exists());

        Ok(())
    }

    #[tokio::test]
    async fn can_create_project_for_existing_repo() -> Result<(), Box<dyn std::error::Error>> {
        let tmp_dir = tempfile::tempdir().expect("failed to create temdir");
        let repo_path = tmp_dir.path().join("radicle");
        let repo_path = repo_path.join("radicalise");
        let key = SecretKey::new();
        let signer = signer::BoxedSigner::from(key.clone());
        let config = config::default(signer.clone(), tmp_dir.path())?;
        let disco = config::static_seed_discovery(&[]);
        let peer = net::peer::Peer::bootstrap(config, disco).await?;
        let (api, _run_loop) = peer.accept()?;
        let state = State::new(api, signer);

        let user = state.init_owner("cloudhead".to_string()).await?;
        let project = state
            .init_project(&user, radicle_project(repo_path.clone()))
            .await;

        assert!(project.is_ok());
        assert!(repo_path.exists());

        Ok(())
    }

    #[tokio::test]
    async fn list_projects() -> Result<(), Box<dyn std::error::Error>> {
        let tmp_dir = tempfile::tempdir().expect("failed to create temdir");
        let repo_path = tmp_dir.path().join("radicle");

        let key = SecretKey::new();
        let signer = signer::BoxedSigner::from(key.clone());
        let config = config::default(signer.clone(), tmp_dir.path())?;
        let disco = config::static_seed_discovery(&[]);
        let peer = net::peer::Peer::bootstrap(config, disco).await?;
        let (api, _run_loop) = peer.accept()?;
        let state = State::new(api, signer);

        let user = state.init_owner("cloudhead".to_string()).await?;

        let _ = control::setup_fixtures(&state, &user)
            .await
            .expect("unable to setup fixtures");

        let kalt = state.init_user("kalt".to_string()).await?;
        let fakie = state.init_project(&kalt, fakie_project(repo_path)).await?;

        let projects = state.list_projects().await?;
        let mut project_names = projects
            .into_iter()
            .map(|project| project.subject().name.to_string())
            .collect::<Vec<_>>();
        project_names.sort();

        assert_eq!(
            project_names,
            vec!["Monadic", "monokel", "open source coin", "radicle"]
        );

        assert!(!project_names.contains(&fakie.subject().name.to_string()));

        Ok(())
    }

    #[tokio::test]
    async fn list_users() -> Result<(), Box<dyn std::error::Error>> {
        let tmp_dir = tempfile::tempdir().expect("failed to create temdir");
        let key = SecretKey::new();
        let signer = signer::BoxedSigner::from(key.clone());
        let config = config::default(signer.clone(), tmp_dir.path())?;
        let disco = config::static_seed_discovery(&[]);
        let peer = net::peer::Peer::bootstrap(config, disco).await?;
        let (api, _run_loop) = peer.accept()?;
        let state = State::new(api, signer);

        let _cloudhead = state.init_user("cloudhead".to_string()).await?;
        let _kalt = state.init_user("kalt".to_string()).await?;

        let users = state.list_users().await?;
        let mut user_handles = users
            .into_iter()
            .map(|user| user.subject().name.to_string())
            .collect::<Vec<_>>();
        user_handles.sort();

        assert_eq!(user_handles, vec!["cloudhead", "kalt"],);

        Ok(())
    }
}
